// Generated by CoffeeScript 1.6.2
var tddjs;

tddjs = (function() {
  var namespace;

  namespace = function(string) {
    var level, levels, object, _i, _len;

    object = this;
    levels = string.split(".");
    for (_i = 0, _len = levels.length; _i < _len; _i++) {
      level = levels[_i];
      if (typeof object[level] === "undefined") {
        object[level] = {};
      }
      object = object[level];
    }
    return object;
  };
  return {
    namespace: namespace
  };
})();

tddjs.isOwnProperty = (function() {
  var hasOwn;

  hasOwn = Object.prototype.hasOwnProperty;
  if (typeof hasOwn === "function") {
    return function(object, property) {
      return hasOwn.call(object, property);
    };
  }
})();

tddjs.extend = (function() {
  var extend;

  extend = function(target, source) {
    target = target || {};
    if (!source) {
      return target;
    }
    tddjs.each(source, function(prop, val) {
      return target[prop] = val;
    });
    return target;
  };
  return extend;
})();


tddjs.each = (function () {
  // Returns an array of properties that are not exposed
  // in a for-in loop
  function unEnumerated(object, properties) {
    var length = properties.length;

    for (var i = 0; i < length; i++) {
      object[properties[i]] = true;
    }

    var enumerated = length;

    for (var prop in object) {
      if (tddjs.isOwnProperty(object, prop)) {
        enumerated -= 1;
        object[prop] = false;
      }
    }

    if (!enumerated) {
      return;
    }

    var needsFix = [];

    for (i = 0; i < length; i++) {
      if (object[properties[i]]) {
        needsFix.push(properties[i]);
      }
    }

    return needsFix;
  }

  var oFixes = unEnumerated({},
    ["toString", "toLocaleString", "valueOf",
     "hasOwnProperty", "isPrototypeOf",
     "constructor", "propertyIsEnumerable"]);

  var fFixes = unEnumerated(
    function () {}, ["call", "apply", "prototype"]);

  if (fFixes && oFixes) {
    fFixes = oFixes.concat(fFixes);
  }

  var needsFix = { "object": oFixes, "function": fFixes };

  return function (object, callback) {
    if (typeof callback != "function") {
      throw new TypeError("callback is not a function");
    }

    // Normal loop, should expose all enumerable properties
    // in conforming browsers
    for (var prop in object) {
      if (tddjs.isOwnProperty(object, prop)) {
        callback(prop, object[prop]);
      }
    }

    // Loop additional properties in non-conforming browsers
    var fixes = needsFix[typeof object];

    if (fixes) {
      var property;

      for (var i = 0, l = fixes.length; i < l; i++) {
        property = fixes[i];

        if (tddjs.isOwnProperty(object, property)) {
          callback(property, object[property]);
        }
      }
    }
  };
}());

tddjs.isHostMethod = (function () {
  function isHostMethod(object, property) {
    var type = typeof object[property];

    return type == "function" ||
           (type == "object" && !!object[property]) ||
           type == "unknown";
  }

  return isHostMethod;
}());
;

tddjs.isLocal = (function() {
  var isLocal;

  isLocal = function() {
    return !!(window.location && window.location.protocol.indexOf("file:") === 0);
  };
  return isLocal;
})();


tddjs.isEventSupported = (function () {
  var TAGNAMES = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };

  function isEventSupported(eventName) {
    var tagName = TAGNAMES[eventName];
    var el = document.createElement(tagName || "div");
    eventName = "on" + eventName;
    var isSupported = (eventName in el);

    if (!isSupported) {
      el.setAttribute(eventName, "return;");
      isSupported = typeof el[eventName] == "function";
    }

    el = null;

    return isSupported;
  }

  return isEventSupported;
}());
;

(function() {
  var addEventHandler, custom, dom, mouseenter, normalizeEvent, _addEventHandler;

  dom = tddjs.namespace("dom");
  _addEventHandler = null;
  if (!Function.prototype.call) {
    return;
  }
  normalizeEvent = function(event) {
    event.preventDefault = function() {
      return event.returnValue = false;
    };
    event.target = event.srcElement;
    return event;
  };
  if (tddjs.isHostMethod(document, "addEventListener")) {
    _addEventHandler = function(element, event, listener) {
      return element.addEventListener(event, listener, false);
    };
  } else if (tddjs.isHostMethod(document, "attachEvent")) {
    _addEventHandler = function(element, event, listener) {
      return element.attachEvent("on" + event, function() {
        event = normalizeEvent(window.event);
        listener.call(element, event);
        return event.returnValue;
      });
    };
  } else {
    return;
  }
  mouseenter = function(el, listener) {
    var current;

    current = null;
    _addEventHandler(el, "mouseover", function(event) {
      if (current !== el) {
        current = el;
        return listener.call(el, event);
      }
    });
    return _addEventHandler(el, "mouseout", function(event) {
      var e, target;

      target = event.relatedTarget || event.toElement;
      try {
        if (target && !target.nodeName) {
          target = target.parentNode;
        }
      } catch (_error) {
        e = _error;
        return;
      }
      if (el !== target && !dom.contains(el, target)) {
        return current = null;
      }
    });
  };
  custom = dom.customEvent = {};
  if (!tddjs.isEventSupported("mouseenter") && tddjs.isEventSupported("mouseover") && tddjs.isEventSupported("mouseout")) {
    custom.mouseenter = mouseenter;
  }
  dom.supportsEvent = function(event) {
    return tddjs.isEventSupported(event) || !!custom[event];
  };
  addEventHandler = function(element, event, listener) {
    if (dom.customEvents && dom.customEvents[event]) {
      dom.customEvents[event](element, listener);
    }
    return _addEventHandler(element, event, listener);
  };
  return dom.addEventHandler = addEventHandler;
})();
